(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/forms')) :
  typeof define === 'function' && define.amd ? define('@ctrl/ngx-codemirror', ['exports', '@angular/core', '@angular/forms'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.ctrl = global.ctrl || {}, global.ctrl['ngx-codemirror'] = {}), global.ng.core, global.ng.forms));
}(this, (function (exports, core, forms) { 'use strict';

  function normalizeLineEndings(str) {
      if (!str) {
          return str;
      }
      return str.replace(/\r\n|\r/g, '\n');
  }
  var CodemirrorComponent = /** @class */ (function () {
      function CodemirrorComponent(_differs, _ngZone) {
          this._differs = _differs;
          this._ngZone = _ngZone;
          /* class applied to the created textarea */
          this.className = '';
          /* name applied to the created textarea */
          this.name = 'codemirror';
          /* autofocus setting applied to the created textarea */
          this.autoFocus = false;
          /* preserve previous scroll position after updating value */
          this.preserveScrollPosition = false;
          /* called when the text cursor is moved */
          this.cursorActivity = new core.EventEmitter();
          /* called when the editor is focused or loses focus */
          this.focusChange = new core.EventEmitter();
          /* called when the editor is scrolled */
          // tslint:disable-next-line:no-output-native
          this.scroll = new core.EventEmitter();
          /* called when file(s) are dropped */
          // tslint:disable-next-line:no-output-native
          this.drop = new core.EventEmitter();
          this.value = '';
          this.disabled = false;
          this.isFocused = false;
          /** Implemented as part of ControlValueAccessor. */
          this.onChange = function (_) { };
          /** Implemented as part of ControlValueAccessor. */
          this.onTouched = function () { };
      }
      Object.defineProperty(CodemirrorComponent.prototype, "options", {
          /**
           * set options for codemirror
           * @link http://codemirror.net/doc/manual.html#config
           */
          set: function (value) {
              this._options = value;
              if (!this._differ && value) {
                  this._differ = this._differs.find(value).create();
              }
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(CodemirrorComponent.prototype, "codeMirrorGlobal", {
          get: function () {
              if (this._codeMirror) {
                  return this._codeMirror;
              }
              this._codeMirror = typeof CodeMirror !== 'undefined' ? CodeMirror : require('codemirror');
              return this._codeMirror;
          },
          enumerable: false,
          configurable: true
      });
      CodemirrorComponent.prototype.ngAfterViewInit = function () {
          var _this = this;
          if (!this.ref) {
              return;
          }
          // in order to allow for universal rendering, we import Codemirror runtime with `require` to prevent node errors
          this._ngZone.runOutsideAngular(function () {
              _this.codeMirror = _this.codeMirrorGlobal.fromTextArea(_this.ref.nativeElement, _this._options);
              _this.codeMirror.on('cursorActivity', function (cm) { return _this._ngZone.run(function () { return _this.cursorActive(cm); }); });
              _this.codeMirror.on('scroll', _this.scrollChanged.bind(_this));
              _this.codeMirror.on('blur', function () { return _this._ngZone.run(function () { return _this.focusChanged(false); }); });
              _this.codeMirror.on('focus', function () { return _this._ngZone.run(function () { return _this.focusChanged(true); }); });
              _this.codeMirror.on('change', function (cm, change) { return _this._ngZone.run(function () { return _this.codemirrorValueChanged(cm, change); }); });
              _this.codeMirror.on('drop', function (cm, e) {
                  _this._ngZone.run(function () { return _this.dropFiles(cm, e); });
              });
              _this.codeMirror.setValue(_this.value);
          });
      };
      CodemirrorComponent.prototype.ngDoCheck = function () {
          var _this = this;
          if (!this._differ) {
              return;
          }
          // check options have not changed
          var changes = this._differ.diff(this._options);
          if (changes) {
              changes.forEachChangedItem(function (option) { return _this.setOptionIfChanged(option.key, option.currentValue); });
              changes.forEachAddedItem(function (option) { return _this.setOptionIfChanged(option.key, option.currentValue); });
              changes.forEachRemovedItem(function (option) { return _this.setOptionIfChanged(option.key, option.currentValue); });
          }
      };
      CodemirrorComponent.prototype.ngOnDestroy = function () {
          // is there a lighter-weight way to remove the cm instance?
          if (this.codeMirror) {
              this.codeMirror.toTextArea();
          }
      };
      CodemirrorComponent.prototype.codemirrorValueChanged = function (cm, change) {
          if (change.origin !== 'setValue') {
              this.value = cm.getValue();
              this.onChange(this.value);
          }
      };
      CodemirrorComponent.prototype.setOptionIfChanged = function (optionName, newValue) {
          if (!this.codeMirror) {
              return;
          }
          // cast to any to handle strictly typed option names
          // could possibly import settings strings available in the future
          this.codeMirror.setOption(optionName, newValue);
      };
      CodemirrorComponent.prototype.focusChanged = function (focused) {
          this.onTouched();
          this.isFocused = focused;
          this.focusChange.emit(focused);
      };
      CodemirrorComponent.prototype.scrollChanged = function (cm) {
          this.scroll.emit(cm.getScrollInfo());
      };
      CodemirrorComponent.prototype.cursorActive = function (cm) {
          this.cursorActivity.emit(cm);
      };
      CodemirrorComponent.prototype.dropFiles = function (cm, e) {
          this.drop.emit([cm, e]);
      };
      /** Implemented as part of ControlValueAccessor. */
      CodemirrorComponent.prototype.writeValue = function (value) {
          if (value === null || value === undefined) {
              return;
          }
          if (!this.codeMirror) {
              this.value = value;
              return;
          }
          var cur = this.codeMirror.getValue();
          if (value !== cur &&
              normalizeLineEndings(cur) !== normalizeLineEndings(value)) {
              this.value = value;
              if (this.preserveScrollPosition) {
                  var prevScrollPosition = this.codeMirror.getScrollInfo();
                  this.codeMirror.setValue(this.value);
                  this.codeMirror.scrollTo(prevScrollPosition.left, prevScrollPosition.top);
              }
              else {
                  this.codeMirror.setValue(this.value);
              }
          }
      };
      /** Implemented as part of ControlValueAccessor. */
      CodemirrorComponent.prototype.registerOnChange = function (fn) {
          this.onChange = fn;
      };
      /** Implemented as part of ControlValueAccessor. */
      CodemirrorComponent.prototype.registerOnTouched = function (fn) {
          this.onTouched = fn;
      };
      /** Implemented as part of ControlValueAccessor. */
      CodemirrorComponent.prototype.setDisabledState = function (isDisabled) {
          this.disabled = isDisabled;
          this.setOptionIfChanged('readOnly', this.disabled);
      };
      return CodemirrorComponent;
  }());
  CodemirrorComponent.decorators = [
      { type: core.Component, args: [{
                  selector: 'ngx-codemirror',
                  template: "\n    <textarea\n      [name]=\"name\"\n      class=\"ngx-codemirror {{ className }}\"\n      [class.ngx-codemirror--focused]=\"isFocused\"\n      autocomplete=\"off\"\n      [autofocus]=\"autoFocus\"\n      #ref\n    >\n    </textarea>\n  ",
                  providers: [
                      {
                          provide: forms.NG_VALUE_ACCESSOR,
                          useExisting: core.forwardRef(function () { return CodemirrorComponent; }),
                          multi: true,
                      },
                  ],
                  preserveWhitespaces: false,
                  changeDetection: core.ChangeDetectionStrategy.OnPush
              },] }
  ];
  CodemirrorComponent.ctorParameters = function () { return [
      { type: core.KeyValueDiffers },
      { type: core.NgZone }
  ]; };
  CodemirrorComponent.propDecorators = {
      className: [{ type: core.Input }],
      name: [{ type: core.Input }],
      autoFocus: [{ type: core.Input }],
      options: [{ type: core.Input }],
      preserveScrollPosition: [{ type: core.Input }],
      cursorActivity: [{ type: core.Output }],
      focusChange: [{ type: core.Output }],
      scroll: [{ type: core.Output }],
      drop: [{ type: core.Output }],
      ref: [{ type: core.ViewChild, args: ['ref', { static: true },] }]
  };

  var CodemirrorModule = /** @class */ (function () {
      function CodemirrorModule() {
      }
      return CodemirrorModule;
  }());
  CodemirrorModule.decorators = [
      { type: core.NgModule, args: [{
                  exports: [CodemirrorComponent],
                  declarations: [CodemirrorComponent],
              },] }
  ];

  /**
   * Generated bundle index. Do not edit.
   */

  exports.CodemirrorComponent = CodemirrorComponent;
  exports.CodemirrorModule = CodemirrorModule;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ctrl-ngx-codemirror.umd.js.map
